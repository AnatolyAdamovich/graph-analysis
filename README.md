# Graphlib

> **Graphlib** — это библиотека, написанная на языке Python,
> для создания, хранения, обработки графов, а также вычисления их основных характеристик.
>
>
> Graphlib предоставляет базовые классы для работы с ориентированными и неориентированными графами.
> В ней реализованы базовые алгоритмы для обхода и исследования графов, 
> а также вспомогательные функции для вычисления и оценки различных характеристик.
>
> Исходный код библиотеки организован таким образом, чтобы была понятна её структура.
>
> Документацию к каждой функции доступна при помощи команды help.
> 
> Все используемые в проекте библиотеки
> указаны в файле requirements.txt
> (который расположен в корневой директории). 

## Содержание:
- Структуры данных и типы графов
- Алгоритмы
- Функции
- Пример использования
- Исследование

***

## Структуры данных и типы графов

- #### Graph — неориентированный граф


```python
class Graph:
    def __init__(self, name='null', nodes=None, edges=None)
```

[[source]](https://github.com/AnatolyAdamovich/graph-analysis/blob/master/graphlib/structures/simple_graph.py)

Базовый класс для неориентированного графа.
В нем реализованы методы:
- возвращение списка ребер
- возвращение списка вершин
- подсчет числа ребер
- подсчет числа вершин
- подсчет числа соседей вершины
- подсчет степени вершины (число выходящих из нее ребер)
- добавление вершины (или сразу нескольких вершин)
- добавление ребра 
- возвращение соседей вершины
- случайная выборка вершин (или наибольшей степени)
- возвращение вершин и их степеней в отсортированном по убыванию порядке
- выделение подграфа исходного графа
- проверка смежности двух вершин
***

- #### Digraph — ориентированный граф


```python
class Digraph:
    def __init__(self, name='null', nodes=None, edges=None)
```

[[source]](https://github.com/AnatolyAdamovich/graph-analysis/blob/master/graphlib/structures/digraph.py)

Базовый класс для ориентированного графа.
Он содержит методы:
- возвращение списка ребер
- возвращение списка вершин
- подсчет числа ребер
- подсчет числа вершины 
- подсчет числа соседей вершины
- подсчет степени вершины (число выходящих из нее ребер)
- добавление вершины (или сразу нескольких)
- добавление ребра
- соседи для вершины
- возвращение вершин и их степеней в отсортированном по убыванию порядке (реализован не полностью)
- случайная выборка вершин (или наибольшей степени)
- подграф исходного графа
- перевод в неориентированный граф
- инвертирование графа (инвертирование всех его дуг)

***

## Алгоритмы

- **Поиск в графе**
    - Поиск в глубину
    - Поиск в ширину
- **Поиск компонент связности**
    - Поиск компонент слабой связности 
    - Поиск компонент сильной связности
        - Алгоритм Тарьяна
        - Алгоритм Косарайю
- **Построение метаграфа**

[[source]](https://github.com/AnatolyAdamovich/graph-analysis/tree/master/graphlib/algorithms)

***

## Функции

Вспомогательные функции, осуществляющие точное или приблизительное вычисление характеристик графа:

- плотность графа
- диаметр
- радиус
- приближенные статистики графа по выборке (диаметр, радиус, квантиль расстояния)
- локальныйкластерный коэффициент, средний кластерный коэффициент
- число треугольников в графе
- локальный кластерный коэффициент
- средний кластерный коэффициент
- глобальный кластерный коэффициент
- создание заданного числа пар вершин с подсчитанным геодезическим расстоянием (landmark-analysis)
- проведение эксперимента с заданными параметрами (landmark-analysis)

[[source]](https://github.com/AnatolyAdamovich/graph-analysis/tree/master/graphlib/tools)

## Пример использования


```python
from graphlib.structures import Digraph

G = Digraph(name='test', edges=[('A', 'B'), ('B', 'D'), ('B', 'E'), ('E', 'B'),
                                ('E', 'G'), ('G', 'K'), ('K', 'I'), ('I', 'G'),
                                ('G', 'H'), ('H', 'K')])
```


```python
from graphlib.algorithms import BFS_search
```


```python
print(BFS_search(G, start_u='B', finish_v='A'))
```

None


```python

```

## Исследование
### 1 часть
В рамках проекта было проведено исследование, посвященное
анализу структуры сетей `Co-Astro`, `Web-Google` и `vk`.
Для исследования использовалась описанная библиотека - **graphlib**.
Для проверки корректности работы библиотеки было осуществлено
параллельное оценивание тех же характеристик сетей с помощью
библиотеки **NetworkX** ([1](https://networkx.org/)), которая традиционно используется для задач подобного рода.
Все полученные характеристики сошлись.


Результаты исследования могут быть найдены в соответствующих (по названию) Jupyter - блокнотах,
расположенных в корневой директории проекта: 
`CO-Astro.ipynb`, `Web-Google.ipynb`, `vk.ipynb`. 


Кроме того, было проведено сравнение времени работы библиотек **graphlib** и **networkx**,
результаты которого расположены в папке `time-comparison`.

### 2 часть
Другой важной задачей проекта была попытка
реализовать алгоритмы оценивания
кратчайших расстояний между вершинами в графах большой размерности
посредством применения landmark-based алгоритмов.

Были изучены статьи, в которых описаны основные принципы упомянутых алгоритмов:
1. Tretyakov, K., Armas-Cervantes, A., García-Bañuelos, L., Vilo, J. & Dumas, M. Fast fully
   dynamic landmark-based estimation of shortest path distances in very large graphs. Proc
   20th Acm Int Conf Information Knowl Management - Cikm ’11 1785–1794 (2011)
   doi:10.1145/2063576.2063834.
2. Potamias, M., Bonchi, F., Castillo, C. & Gionis, A. Fast shortest path distance estimation in
   large networks. Proceeding 18th Acm Conf Information Knowl Management - Cikm ’09 867–
   876 (2009) doi:10.1145/1645953.1646063

В исходном проекте были реализованы:
- **различные стратегии отбора ландмарков**
    - случайный выбор
    - выбор вершин наибольшой степени
    - выбор вершин наименьшей closest centrality
    - выбор вершин best coverage на основе оценивания заданного числа пар
- **оценивание расстояний**
    - базовый landmark-based алгоритм
    - модифицированный landmark-based алгоритм, использующий SPT для каждого ландмарка

Было проведено исследование работы алгоритмов при различных гиперпараметрах 
(разное число отбираемых ландмарков, разные стратегии отбора, разные алгоритмы): 
производилось вычисление точности каждой комбинации различных параметров, затем все данные заносились в таблицу.

По полученным результатам были сформированы гистограммы, характеризующие точность каждой комбинации.
Точность вычислялась по метрике approximation error (чем меньше, тем лучше).

Гистограммы:

Реализация landmark - алгоритмов: [2]()
